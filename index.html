<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Tehnici de Programare</title>
        <link rel="website icon" type="png" href="images/pen.png">
        <link rel="stylesheet" href="css/stylesheet.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/chalk.min.css">
        <link rel="stylesheet" href="link rel="stylesheet href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <script src="https://kit.fontawesome.com/64d58efce2.js" crossorigin="anonymous"></script>
    </head>
    <body>
        <header>
        <div class="hero-image" id="hero-image">
            <div class="hero-text">
                <h2>Tehnici de Programare</h2>
        </div>
        <div id="sideNav">
            <nav>
                <ul>
                    <li><a href="#">ACASĂ</a></li>
                    <li><a href="#introducere">Metoda Trierii</a></li>
                    <li><a href="#ec-omogene_2">Metoda Greedy</a></li>
                    <li><a href="#ec-omogene_3">Recursia</a></li>
                    <li><a href="#ec-omogene_4">Backtracking</a></li>
                    <li><a href="#footer">Final</a></li>
                </ul>
            </nav>
        </div>
    </header>
        <div id="manuBtn">
            <img src="images/menu.png" alt="" id="menu">
        </div>
        <section id="introducere">
            <div class="title-text">
                <p>METODA TRIERII</p>
            </div>
            <div class="feature-box">
                <div class="features">
                    <div class="features-desc">
                        <div class="feature-icon">
                            <i class="fa-solid fa"></i>
                        </div>
                        <div class="feature-text">
                            <p>
                                Se numeşte metoda trierii o metodă ce indentifică toate soluţiile unei probleme în dependenţă de mulţimea soluţiilor posibile.  Toate soluţiile se identifică prin valori, ce aparţin tipurilor de date studiate: integer, boolean, enumerare, char, subdomeniu, tablouri unidimensionale. 
                            </p>
                        </div>
                    </div>
                    <div class="features-desc" style="margin-bottom: initial;">
                        <div class="feature-icon">
                            <i class="fa-solid fa"></i>
                        </div>
                        <div class="feature-text">
                            <p> 
                                Avantajul principal al algoritmilor bazaţi pe metoda trierii constă în faptul că programele respective sunt relativ simple, iar depanarea lor nu necesită teste sofisticate.În majoritatea problemelor de o reală importanţă practică metoda trierii conduce la algoritmiii exponenţiali. Întrucît algoritmii exponenţiali sunt inacceptabili în cazul datelor de intrare foarte mari,metoda trierii este aplicată numai în scopuri didactice sau pentru elaborarea unor programe al căror timp de execuţie nu este critic.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="features-img">
                    <img src="images/trierii.png" alt="">
                </div>
            </div>
        </section>
        <section id="exempleI">
            <div class="title-text">
                <p>EXEMPLE</p>
            </div>
            <div class="row">
                <div class="column">
                <h2 class="title_prob">Să se determine mulțimea care reprezintă reuniunea a două mulțimi de numere întregi (reale). 
                Elementele mulțimilor A și B vor fi introduse de la tastatură.</h2>
                <pre>
                    <code class="language-cpp" style="background: rgb(130, 90, 99); font-size: 15px;">
                        
    #include  &ltiostream&gt
    using namespace std;

    int main(){
        int a[20],b[20],c[50],i,j,m,n,k=0,gasit;
        cout<<"\nNumărul de elemente al mulțimii A este: "; 
        cin>>n;
        for(i=0;i<=n-1;i++) cin>>a[i];
        cout<<"\nNumărul de elemente al mulșimii B este: "; 
        cin>>m;
        for(j=0;j<=m-1;j++) cin>>b[j];
       for(i=0;i<=n-1;i++){
       gasit=0;
        for(j=0;j<=m-1 && !gasit;j++)
        if (a[i]==b[j]) gasit=1;
        if (!gasit) c[k++]=a[i];
       }
        cout<<"\nReuniunea multimilor: \n{ ";
        for (i=0;i<=n-1;i++) 
        cout << a[i] << " " ; cout<<"} și { ";
        for (j=0;j<=m-1;j++) 
        cout << b[j] << " " ; cout << " } este:\n\n{ ";
        for(i=0; i <= m-1; i++)
        cout << b[i] << " " ;
        for(i=0; i < k ; i++)
        cout << c[i] << " "; cout << " } " ;
    }
                    </code>
                </pre>
            </div>
                <div class="column">
                <h2 class="title_prob">Să se genereze toate submulțimile mulțimii A de numere întregi. 
                Numărul de elementele al mulțimii A va fi introdus de la tastatură.</h2>
                <pre>
                    <code class="language-cpp" style="background: #2a68507a; font-size: 15px;">
                       


        #include &ltiostream&gt
        using namespace std;
        
        int a[10], n, i, S;
int main(){
cout << "\nNumarul de elemente al multimii A este: "; 
cin>>n;
for(i=0; i<n;i++)
a[i]=0;
do{
a[n-1]++;
for(i=n-1; i>=1; i--)
if(a[i]>1){
a[i]-=2; a[i-1]+=1;
}
S=0;
for(i=0; i < n; i++)
S+=a[i];
for(i=0; i < n ;  i++)
if(a[i]) cout << i+1 << " " ;
cout << endl;
}
while(S < n);
cout << " Mulțime vidă! " ;
}
                             
                    </code>
                </pre>
            </div>
            <div class="column">
                <h2 class="title_prob">Se citeşte de la tastatură un număr natural. 
                Să se decidă dacă acesta poate fi scris ca şi sumă de două pătrate şi să se afişeze toate soluţiile găsite.</h2>
                <pre>
                    <code class="language-cpp" style="background: rgb(130, 90, 99); font-size: 15px;">

        #include &lt;iostream&gt;
        #include &lt;math.h&gt;
            using namespace std;
            bool verif_nr(float nr){
            bool patrat=false;
            if ((sqrt(nr)*sqrt(nr)) == nr)
            patrat=true;
            return patrat;
            }
            int main(){
            float nr, nr1, nr2=0;
            cout<<"Introduceti numarul natural: ";
            cin>>nr;
            cout<<"Suma de patrate perfecte: \n";
            for(nr1=2; nr1 <= nr/2; nr1++){
            if(verif_nr(nr1)){
            nr2=nr-nr1;
            if(verif_nr(nr2))
            cout<<"\t"<< nr <<"=" << sqrt(nr1) 
            <<"^2"<<" + " << sqrt(nr2) <<" ^2 "<< endl;
            }
            }
            return 0; 
        }
            
        
                            
                    </code>
                </pre>
            </div>
        </div>
        </section>
        <section id="ec-omogene_2">
            <div class="title-text">
                <p>METODA GREEDY</p>
            </div>
            <div class="feature-box">
                <div class="features">
                    <div class="features-desc">
                        <div class="feature-icon">
                            <i class="fa-solid fa"></i>
                        </div>
                        <div class="feature-text">
                            <p>
                                Metoda greedy este o strategie de rezolvare a problemelor algoritmice în care se iau decizii locale optime în fiecare pas, cu speranța că acestea vor conduce la o soluție globală optimă. Cu alte cuvinte, algoritmul greedy face alegeri la fiecare pas, alegând opțiunea cea mai bună disponibilă în acel moment, fără a lua în considerare consecințele viitoare.
                        </div>
                    </div>
                    <div class="features-desc">
                        <div class="feature-icon">
                            <i class="fa-solid fa"></i>
                        </div>
                        <div class="feature-text">
                            <p> 
                                Deoarece algoritmul greedy nu ia în considerare întotdeauna imaginea de ansamblu a problemei și se concentrează doar pe soluții locale, există riscul ca acesta să nu ajungă la cea mai bună soluție globală. Cu toate acestea, metoda greedy poate fi foarte eficientă și ușor de implementat în anumite contexte.
                            </p>
                        </div>
                    </div>                  
                </div>
            <div class="features-img">
                <img src="images/greedy3.gif" alt="">
            </div>
            </div>
        </section>
            <section id="exempleI">
                <div class="title-text">
                    <p>EXEMPLE</p>
                </div>
                <div class="row">
                    <div class="column">
                    <h2 class="title_prob">La un birou care se ocupă cu analiza proiectelor de investiții, n investitori au depus până la termenul legal câte un proiect. Cunoscând timpul necesar pentru analiza fiecărui proiect, scrieți un program care determină ordinea în care vor fi analizate proiectele, astfel încât timpul mediu de așteptare pentru investitori să fie minim. </h2>
                    <pre>
                        <code class="language-cpp" style="background: rgb(130, 90, 99); font-size: 15px;">





        #include &lt;iostream&gt;
        using namespace std;

        ifstream cin("proiecte.in");
        ofstream cout("proiecte.out");
        
        int n;

        struct proiect {
            int timp;
            int poz;
        }a[1001];
        
        void sortare (proiect a[], int n) {
        for (int i=1; i< n; ++i)
        for (int j=i+1; j<=n; ++j)
        if (a[i].timp > a[j].timp)
        swap(a[i],a[j]);
    }
        
        int main(){
        cin >> n;
        for(int i = 1; i <= n; ++i) 
        cin >> a[i].timp, a[i].poz=i;
        sortare (a, n);
        for( int i=1; i<=n; ++i)
        cout << a[i].poz<<' ';
        return 0;
        }
                        </code>
                    </pre>
                </div>
                    <div class="column">
                    <h2 class="title_prob">Se dau 3 numere naturale n a b, 1 <= a < b < n. Să se determine o modalitate  de a-i scrie pe n ca sumă de termeni egali cu a sau b în care numărul de termeni egali cu a este maxim. </h2>
                    <pre>
                        <code class="language-cpp" style="background: #2a68507a; font-size: 15px;">


            #include &lt;iostream&gt;
            using namespace std;
            
            int n, a, b;
            int cntb, cnta;

            int main(){
                cin >> n >> a >> b;
                while(n % a && n > 0)
                n -= b, cntb++;
                while (n)
                n -= a, cnta++;
                for(int i=1; i<= cnta; ++i)
                cout << a << ' ';
                for(int i=1; i<= cntb; ++i)
                cout << b << ' ';

                return 0;
            }
                                 
                        </code>
                    </pre>
                </div>
                <div class="column">
                    <h2 class="title_prob"> La un festival sunt programate n spectacole. Pentru fiecare se cunoaște momentul de început și momentul de sfârșit, exprimate prin numere naturale. Un spectator dorește să urmărească cât mai multe spectacole în întregime. Determinați numărul maxim de spectacole care pot fi urmărite, fără ca acestea să se suprapună</h2>
                    <pre>
                        <code class="language-cpp" style="background: rgb(130, 90, 99); font-size: 15px;">
                            
        #include &lt;iostream&gt;
        using namespace std;

        ifstream cin("spectacole.in");
        ofstream cout("spectacole.out");
        
        struct spectacol{
        int start, finish;
        }a[101];
        
        int n;

        void sortare spectacole(spectacol a[], int n) {
            for (int i=1; i < n; ++i )
            for(int j=i+1; j <= n; ++j)
            if(a[i].finish > a[j].finish)
            swap(a[i], a[j]);
        }
        
        int main; {
        cin >> n;
        for(int i=1; i <= n; ++i)
        cin >> a[j].start >> a[i].finish;
        sortare_spectacole(a, n);
        int cnt=1;
        int ora_fin = a[1].finish;
        for(int = 2; i <= n; ++i)
        if(ora_fin <= a[i].start) {
            cnt++;
            ora_fin = a[i].finish;
        }
        cout << cnt;
        return 0;
    }
                                
                        </code>
                    </pre>
                </div>
            </div>
            </section>
            <section id="ec-omogene_3">
                <div class="title-text">
                    <p>RECURSIA</p>
                </div>
                <div class="feature-box">
                    <div class="features">
                        <div class="features-desc">
                            <div class="feature-icon">
                                <i class="fa-solid fa"></i>
                            </div>
                            <div class="feature-text">
                                <p>
                                    Recursia este o tehnică de programare în care o funcție se apelează pe sine pentru a rezolva o problemă mai mică, similară cu cea inițială. Adică, o funcție recursivă rezolvă o problemă printr-o serie de apeluri repetitive la ea însăși, adesea cu date de intrare mai mici, până când se atinge o condiție de oprire și problema poate fi rezolvată direct, fără a mai face alte apeluri recursive.
                                </p>
                            </div>
                        </div>
                        <div class="features-desc">
                            <div class="feature-icon">
                                <i class="fa-solid fa"></i>
                            </div>
                            <div class="feature-text">
                                <p> 
                                    Prin utilizarea recursiei, probleme complexe pot fi descompuse în probleme mai simple și mai ușor de gestionat. Recursia este adesea folosită în programare pentru a simplifica soluționarea problemelor și pentru a face codul mai concis și mai ușor de înțeles în anumite situații.
                                </p>
                            </div>
                        </div>                  
                    </div>
                <div class="features-img">
                    <img src="images/recursia3.png" alt="">
                </div>
                </div>
            </section>
                <section id="exempleI">
                    <div class="title-text">
                        <p>EXEMPLE</p>
                    </div>
                    <div class="row">
                        <div class="column">
                        <h2 class="title_prob">Mihai a învățat la școală despre ridicarea la putere. Ajută-l să calculeze a^b, folosind o funcție recursivă.</h2>
                        <pre>
                            <code class="language-cpp" style="background: rgb(130, 90, 99); font-size: 15px;">
        #include &lt;iostream&gt;
        using namespace std;
        
        int a_la_b(int a, int b) {
            if (b == 0 )
            return 1;
            else
            return a_la_b(a, b-1) * a;
        }
         int main()
          int a, b;
          cin >> a >> b;
          cout << a_la_b(a, b )
          return 0;
    
    </code>
                        </pre>
                    </div>
                        <div class="column">
                        <h2 class="title_prob">Se citește un număr n. Să se scrie n ca sumă de puteri crescătoare ale lui 2.</h2>
                        <pre>
                            <code class="language-cpp" style="background: #2a68507a; font-size: 15px;">
    
            #include &lt;iostream&gt;
            using namespace std;

            void rec (int n, int put ) {
                if(n == 0)
                return 0;
                if(n%2 == 0)
                rec(n / 2, put * 2);
                else
                cout << put << ' ', rec(n/2, put * 2);
            }
            int main() {

                int n;
                cin >> n;
                rec(n, 1);

                return 0;
            }
                                     
                            </code>
                        </pre>
                    </div>
                    <div class="column">
                        <h2 class="title_prob"> Să se calculeze factorialul unui număr.</h2>
                        <pre>
                            <code class="language-cpp" style="background: rgb(130, 90, 99); font-size: 15px;">               
        #include &lt;iostream&gt;
        using namespace std;
        int factorial(int n) {
            if(n <= 0) { 
                return 1;
            } else { 
                return n * factorial(n - 1);
            }
        }
        
        int main()
        {
            int n;
            cin >> n;
            cout << factorial(n);
            return 0;
        }
       
                                    
                            </code>
                        </pre>
                    </div>
                </div>
                </section>
                <section id="ec-omogene_4">
                    <div class="title-text">
                        <p>BACKTRACKING</p>
                    </div>
                    <div class="feature-box">
                        <div class="features">
                            <div class="features-desc">
                                <div class="feature-icon">
                                    <i class="fa-solid fa"></i>
                                </div>
                                <div class="feature-text">
                                    <p>
                                        Backtracking este o tehnică algoritmicație utilizată pentru a găsi toate soluțiile posibile ale unei probleme combinatorii. Această tehnică explorează recursiv toate opțiunile disponibile la fiecare pas și se retrage (backtrack) atunci când se constată că soluția parțială nu poate fi extinsă la o soluție validă completă. În esență, backtracking-ul este o metodă de căutare și enumerare a soluțiilor.
                                    </p>
                                </div>
                            </div>
                            <div class="features-desc">
                                <div class="feature-icon">
                                    <i class="fa-solid fa"></i>
                                </div>
                                <div class="feature-text">
                                    <p> 
                                        Principiul de bază al metodei backtracking constă în a încerca să construiți o soluție pas cu pas, luând decizii la fiecare pas și revenind înapoi (backtrack) dacă o anumită cale nu duce la o soluție viabilă. În timpul explorării, se utilizează un mecanism de revenire la starea anterioară pentru a încerca alternative.Această tehnică este adesea folosită pentru rezolvarea problemelor combinatorice, cum ar fi căutarea unui șir de acțiuni care să ducă la o soluție, unde deciziile luate într-un moment determinat pot afecta soluția finală.
                                    </p>
                                </div>
                            </div>                  
                        </div>
                    <div class="features-img">
                        <img src="images/backtracking.png" alt="">
                    </div>
                    </div>
                </section>
                    <section id="exempleI">
                        <div class="title-text">
                            <p>EXEMPLE</p>
                        </div>
                        <div class="row">
                            <div class="column">
                            <h2 class="title_prob">Se citește un cuvânt format doar din litere
                                mici distincte. Să se genereze anagramele
                                acestui cuvânt.</h2>
                            <pre>
                                <code class="language-cpp" style="background: rgb(130, 90, 99); font-size: 15px;">





  #include &lt;iostream&gt;
 #include &lt;string.h&gt;
 using namespace std;
    int x[100],pus[100],n,nr=0;
     char s[100];
  void afiseaza(){
     for(int i=1;i <= n;i++)
     cout << s[x[i]-1];
 cout << endl;
     nr++;
 }
 void btk(int k){
 for(int i=1;i<= n;i++)
    if(!pus[i]){
     x[k]=i; pus[i]=1;
    if( k == n ) afiseaza();
   else btk(k+1);
    pus[i]=0;
     }
     }
     int main(){
     cout << "Introdu un cuvânt: "; cin >> s;
 n=strlen(s);
 cout << endl;
cout <<"Anagramele cuvântului "<< s <<" sunt: \n";
btk(1);
 cout << endl;
 cout << " TOTAL " << nr <<" SOLUȚII " ;
     }
                                </code>
                            </pre>
                        </div>
                            <div class="column">
                            <h2 class="title_prob">Se citește un număr natural n și apoi n culori 
                                distincte date ca șiruri de caractere. Afișați 
                                toate drapelele care se pot forma cu câte 3 
                                culori diferite.
                                </h2>
                            <pre>
                                <code class="language-cpp" style="background: #2a68507a; font-size: 15px;">
        



                                    
        #include &lt;iostream&gt;
        using namespace std;
        
       
        int x[100],pus[100],n,nr=0;
        char s[30][30];
        void afisare(){
         for(int i=1;i<=3;i++) cout<<"\t"<<s[x[i]];
         cout<<endl;
         nr++;
        }
        void btk(int k){
         for(int i=1;i<=n;i++)
         if(!pus[i]){
         x[k]=i; pus[i]=1;
         if(k==3) afisare();
         else btk(k+1);
         pus[i]=0;
         }
        }
        int main(){
         cout << "Introduceti un numar natural: ";cin >> n;
         cout << "Introduceti cele "<< n <<" culori:\n";
         for(int i=1;i <=n ;i++) cin>>s[i];
         cout << "Drapelele formate din " << n 
        <<" culori aranjate câte 3 sunt: \n " ;
         btk(1);
         cout << endl ;
         cout << " TOTAL "<< nr << " SOLUȚII " ;
        }                            
                                         
                                </code>
                            </pre>
                        </div>
                        <div class="column">
                            <h2 class="title_prob"> În curtea lui Adrei se află n găini și m 
                                rațe. Să se aranjeze în toate modurile cele n 
                                găini și m rațe astfel încat nici o găină să nu 
                                fie așezată între două rațe.
                                </h2>
                            <pre>
                                <code class="language-cpp" style="background: rgb(130, 90, 99); font-size: 15px;">     

     #include &lt;iostream&gt;
 int x[100],pus[100],n,m,nr=0;
  void aranjare(){
    for(int i=1;i<=n+m;i++)
     if(x[i]==1) cout<<"G ";
    else cout<<"R ";
cout << endl; nr++;
}
int condiție(int k){
 int c=0,p=0,i;
 for(i=1;i<=k;i++)
if(x[i]==0) c++;
 else p++;
if(p>n || c>m) return 0;
if(k>=3) if(x[k-2]==0 && x[k-1]==1
 && x[k]==0) return 0;
       return 1;
        }
         void btk(int k){
      for(int i=1;i>=0;i--){
     x[k]=i;
        if(conditie(k))
       if(k==n+m) aranjare();
        else btk(k+1);
       }
      }
     int main(){
    cout << "Introduceți două numere naturale: ";
    cin>>n>>m;cout << endl;
     cout << "Pentru " << n <<" gaini si "
     << m <<" rate avem aranjarile:\n";
     btk(1);
     cout << endl ; cout<<"TOTAL " << nr << " SOLUTII";
     return 0;
  }
                                        
                                        
                                </code>
                            </pre>
                        </div>
                    </div>
                    </section>
        <section id="footer">
           
            <div class="footer-row">
                <div class="footer-left">
                    <h1>Realizat de:</h1>
                    <i class="fa fa-solid fa-arrow-right"></i>Oroșan Sofia</p>
                </div>
                
                <div class="footer-middle">
                    "Informatica nu este doar despre calculatoare și cod. Este despre a rezolva probleme, a învăța și a face lucrurile să funcționeze mai bine." 
                   </div>
                </code>
            <div class="social-links">
         <p> &copy; 2023 - O.S.</p>
            </div>
        </section>
        <script src="js/script.js"></script>
        <script type="text/javascript">
            window.addEventListener("scroll", function() {
              var header = document.querySelector("header");
              header.classList.toggle("sticky", window.scrollY > 0);
            });     
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
    </body>
</html>